####debug
--10 centos 7 not work

--20 operation
$>awk -D -f some-file.awk operation-fiel
gawk> watch s
Watchpoint 1: s
gawk> run
Starting program: 
Stopping in Rule ...
Watchpoint 1: s
  Old value: untyped variable
  New value: " rule 10 permit ip source #4 #5 destination #10"
main() at `replace.awk':7
7                          for (j = 1; j <= NF; j++){
gawk> n
8                                  gsub("#"j, $j, s)
gawk> 
Watchpoint 1: s
  Old value: " rule 10 permit ip source #4 #5 destination #10"
  New value: " rule 10 permit ip source #4 #5 destination -R10"
main() at `replace.awk':7
7                          for (j = 1; j <= NF; j++){
gawk> 
8                                  gsub("#"j, $j, s)
gawk> quit
The program is running. Exit anyway (y/n)? y


####debug


######vlookup#################
--10 link
https://unix.stackexchange.com/questions/257002/vlookup-work-in-awk-on-linux

--20 requirement
file1:
4,abc
3,xyz
5,fut
6,gfd

file2:
gfd,2.3
xyz,4.5
abc,6.7
fut,3.2

fil3:(result)
4,6.7
3,4.5
5,3.2
6,2.3

--30 way 1
With join:

join -t, -1 2 -2 1 -o 1.1,2.2 <(sort -t, -k2 file1) <(sort -t, -k1 file2)

    -t, set delimiter to ,.
    -1 2 the first files join field is the second one.
    -2 1 the second files join field is the first one.
    -o 1.1,2.2 the output format
    <(sort ...) join need input files, which are sorted on the join field.

--30 way 2

FNR==NR{
    var[$2]=$1
}
FNR!=NR{
    print(var[$1]","$2)
}

call:
awk -F, -f script.awk file1 file2
######vlookup#################


####warp awk in shell########
--10 $1 is shell argv1,$2 is shell argv2
$> cat segw.sh 
awk 'BEGIN {RS = ""} /'$1'/' $2 

--20 seperate is space line 
$> cat templete.bak 
Interface:g0/0
IP:192.168.1.1

Mask:255.255.255.0
GW:172.16.1.2

--30 call and result,$1 is IP,$2 is templete.bak
$> ./segw.sh IP templete.bak 
Interface:g0/0
IP:192.168.1.1

####warp awk in shell########



###replace newline enter to space####
link:
https://stackoverflow.com/questions/1251999/how-can-i-replace-a-newline-n-using-sed

#10 initial
$>cat templete.bak 
Interface:g0/0
IP:192.168.1.1
Mask:255.255.255.0
GW:172.16.1.2

#20 way 1 the best
$> awk -F ":" '{print $1}' templete.bak |sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g'
Interface IP Mask GW

--or--
#20 way 2
$> awk -F ":" '{print $1}' templete.bak |sed ':a;N;$!ba;s/\n/ /g'
Interface IP Mask GW

Explanation:

    Create a label via :a.
    Append the current and next line to the pattern space via N.
    If we are before the last line, branch to the created label $!ba ($! means not to do it on the last line as there should be one final newline).
    Finally the substitution replaces every newline with a space on the pattern space (which is the whole file).


###replace newline enter to space####


#####awk form-letter with given value####

User~/> cat replace.value 

Fld1|Fld2|Fld3
Alice|Bob|Cindy
Zoo|Yard|Xeon

User~/> cat replace.cmd 
 BEGIN {FS = "|"
                   while (getline <"form.letter")
                   line[++n] = $0
   }
 NR<2{next}{for (i = 1; i <= n; i++) {   //skip first line 
                   s = line[i]          //read line of form.letter to s
                   for (j = 1; j <= NF; j++)  //read field from replace.value in order
                              gsub("\\$"j, $j, s)
                   print s
           }
   }

User~/> cat form.letter 
This is a form letter.
The first field is $1, the second $2, the third $3.
The third is $3, second is $2, and first is $1.

User~/> awk -f replace.cmd replace.value 

This is a form letter.
The first field is Alice, the second Bob, the third Cindy.
The third is Cindy, second is Bob, and first is Alice.

This is a form letter.
The first field is Zoo, the second Yard, the third Xeon.
The third is Xeon, second is Yard, and first is Zoo.


#####awk form-letter with given value####


{
if($0 ~"Directory\ of")  #根据是否含“Directory of”判断是否是包含目录的那一行
        {
f=""         
for(i=3;i<=NF;i++) 
f=f " " $i    
        }#以上为把完整的路径赋给变量f
else
        {
printf("%s\\",f) #打印完整路径，并跟一个\
for(i=5;i<=NF;i++)printf("%s ",$i) #打印完整文件名称,注意%s后的空格,用于输出文件名中的空格.
                {
                printf("|") #打印界定符，方便EXCEL导入
                printf("%s",$4)  #打印所有者
                printf("|") #打印界定符，方便EXCEL导入
                print $3 #打印文件大小
                }
        }
}






awk输出全路径文件及文件大小.txt
dir  c: /s |grep -v "<DIR>|字节$|^$"| awk -v f="" -f 1.txt #-v必须紧随在AWK后，不然会错


下面是1.txt 的内容
{
if($0 ~".*的目录$")         #~是包含的操作方法

        #自定义变量f不需要加前缀$;""""(也可以是空格如$1 " " $2)是字符串之间的连接操作符
        {
f=""         #变量f赋初值，一定要在写在这里
for(i=1;i<NF;i++) #路径的值赋给变量f
f=f " " $i    #路径的值赋给变量f
        }
else
        {
printf("%s\\",f) #输出文件完整路径（包括空格） 
for(i=4;i<=NF;i++)printf("%s ",$i) #接着上面的输出文件完整名称（包括空格） 
print $3  #输出字节数
printf("\n")  #换行
        }
}


结果象这样（注意路径和文件名内部的空格都保留的哦^_^）
 C:\Documents and Settings\All Users\Application Data\Microsoft\OFFICE\DATAOPA11.BAK 8,200

 C:\Documents and Settings\All Users\Application Data\Microsoft\OFFICE\DATAopa11.dat 8,206

 C:\Documents and Settings\All Users\Application Data\Microsoft\USMTiconlib.dll 2,560

 C:\Documents and Settings\All Users\Application Data\Windows Genuine Advantage\Datadata.dat 3,104

 C:\Documents and Settings\All Users\桌面Google Chrome.lnk 1,723

 C:\Documents and Settings\All Users\「开始」菜单Windows Update.lnk 1,411

 C:\Documents and Settings\All Users\「开始」菜单Windows Catalog.lnk 398

