######Startmemoof powershell.memo #######
######Start powershell.memo #######

#######winrm with powershell remote copy file run powershell script set schdule#####
###05 prequest
 client need add to AD? with 5986 port openning 
 operation user is remote Administrators with AD user privileges 
###10 copy file
$TargetSession = New-PSSession -ComputerName your-srv -Port  5986  -Credential Domain\User -UseSSL -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck)
Copy-Item  -ToSession $TargetSession -Path "f:\Script.ps1"  -Destination "C:\Script.ps1" 

###15 set login Credentials
$Password=Read-host "Enter PASSWORD" -AsSecureString
$User="Domain\User"
$Cred=new-object System.Management.Automation.PSCredential($User,$Password)
###20 winrm run on remote vm
Invoke-Command  -Port 5986  -Credential  $Cred -UseSSL `
         -ThrottleLimit 4 -AsJob -ComputerName your-srv `
         -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck)`
         -scriptblock {
              Set-ExecutionPolicy -ExecutionPolicy Unrestricted

    ###20-10 run script once 
              powershell.exe -File "C:\Script.ps1"         
    ###20-20 add to schdule
              $POWERSHELL='C:\Windows\system32\WindowsPowerShell\v1.0\powershell.exe'    
              $USER='Domain\User' 
              $TASKNAME='MySchdule'
              $PASSWORD="your-srv-pw"
              $Action = New-ScheduledTaskAction -Execute "$POWERSHELL" -Argument "-noninteractive -NoLogo -NoProfile -File 'C:\Script.ps1'"
              $Trigger = New-ScheduledTaskTrigger -AtStartup
              $Task = New-ScheduledTask -Action $Action -Trigger $Trigger -Settings (New-ScheduledTaskSettingsSet)
              $Task | Register-ScheduledTask -TaskName $TASKNAME -User $USER -Password "$PASSWORD"
              Start-ScheduledTask -TaskName $TASKNAME 
                
              Set-ExecutionPolicy -ExecutionPolicy Restricted
                }     

###30 check
Enter-PSSession  -ComputerName your-srv -Port  5986  -Credential  Domain\User


#######winrm with powershell remote copy file run powershell script set schdule#####

###export arrays to csv
--10 code 
$serverList = import-csv "C:\Users\datafile.csv"
write-host "====initial serverlist start========"
$serverList
write-host "====initial serverlist end=========="
write-host ""

write-host "====initial Allobjects start========"
$AllObjects = @()
write-host "====initial Allobjects end=========="
write-host ""

$AllObjects
$serverList | ForEach-Object {
    $AllObjects += [pscustomobject]@{
        Servername = $_.Servername
        Name = $_.Servername
        Blk = ""
        Blk2 = ""
        Method = "RDP"
        Port = "3389"
    }
}

write-host "=======filled Allobjects start========="
$AllObjects
write-host "=======filled Allobjects end==========="
$AllObjects | Export-Csv -Path "outfile.csv" -NoTypeInformation


--20 result
====initial serverlist start========


Servername : a1
Name       : 
Blk        : 
Blk2       : 
Method     : RDP
Port       : 3389

Servername : a2
Name       : 
Blk        : 
Blk2       : 
Method     : 
Port       : 

Servername : a3
Name       : 
Blk        : 
Blk2       : 
Method     : 
Port       : 

====initial serverlist end==========

====initial Allobjects start========  ####empty value 
====initial Allobjects end==========  ####empty value 

=======filled Allobjects start=========
Servername : a1
Name       : a1
Blk        : 
Blk2       : 
Method     : RDP
Port       : 3389

Servername : a2
Name       : a2
Blk        : 
Blk2       : 
Method     : RDP
Port       : 3389

Servername : a3
Name       : a3
Blk        : 
Blk2       : 
Method     : RDP
Port       : 3389

=======filled Allobjects end===========
###export arrays to csv

###export csv to arrays
--10 code 
$userdata= Import-CSV C:\Users\\Desktop\pa.csv
$userdata 

ForEach($row in $userdata)
		{
		if($row.Status -EQ "Y"){
				write-host $row.vm,'was',$row.Description}
		}


--20 result 
PS C:\Users\> $userdata= Import-CSV C:\Users\\Desktop\pa.csv
$userdata 

VM  Description NumCpu Status
--  ----------- ------ ------
VM1 SQL VM      4      Y     
VM2 App VM      2      Y     
VM3 VCenter     4      N     
VM4 Redis       8      N     


--30 operation
PS C:\Users\> ForEach($row in $userdata)
		{
		if($row.Status -EQ "Y"){
				write-host $row.vm,'was',$row.Description}
		}
VM1 was SQL VM
VM2 was App VM


###export csv to arrays

####powershell operation wsus
 Install-Module PSWindowsUpdate -MaximumVersion 1.5.2.6
 Get-Command -Module PSWindowsUpdate
 Get-WindowsUpdate
 Get-WUInstall -AcceptAll
####powershell operation wsus

#####parallel process on remote windows server 
$Password=Read-host "Enter PASSWORD" -AsSecureString
$User="Domain\user"
$Cred=new-object System.Management.Automation.PSCredential($User,$Password)
$job=Invoke-Command  -Port 5986  -Credential  $Cred -UseSSL -ThrottleLimit 4 -AsJob -ComputerName (Get-Content e:\list.csv) -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck) -scriptblock {
    hostname.exe
    Get-MpComputerStatus
} 

Receive-job $job -keep
###########

####loop opertion https://en.wikiversity.org/wiki/PowerShell/Loops
While

The while statement runs a statement list zero or more times based on the results of a conditional test.[1]

$i = 0
while($i -lt 3)
{
    Write-Output $i
    $i++
}

Do While

The do while statement runs a statement list one or more times based on the affirmative results of a conditional test.[2]

$i = 0
do
{
    Write-Output $i
    $i++
}while($i -lt 3)

It is important to note that, unlike while, a do while or do until will always execute at least once.

$i = 0
do
{
    Write-Output $i
    $i--
}while($i -gt 0)

Do Until

The do until statement runs a statement list one or more times based on the negative results of a conditional test.[3]

$i = 0
do
{
    Write-Output $i
    $i++
}until($i -ge 3)

For

The for statement runs a statement list zero or more times based on an initial setting, a conditional test, and a repeated statement, most often used with numeric counters.[4]

for($i = 0; $i -lt 3; $i++)
{
    Write-Output $i
}

For loops are often nested to repeat actions, such as for rows and columns. For example:

for($i = 0; $i -lt 3; $i++)
{
    $line = ''
    for($j = 0; $j -lt 3; $j++)
    {
        $line += $i.ToString() + $j.ToString() + '  '
    }
    Write-Output $line
}

ForEach

The foreach statement runs a statement list once for each item in a collection.[5]

$processes = Get-Process
foreach($process in $processes)
{
    if($process.PM / 1024 / 1024 -gt 100)
    {
        Write-Output ('Process ' + $process.Name + ' is using more than 100 MB RAM.')
    }
}

Continue

The continue statement immediately returns script flow to the top of the innermost While, Do, For, or ForEach loop.[6]

$processes = Get-Process
foreach($process in $processes)
{
    if($process.PM / 1024 / 1024 -le 100)
    {
        continue
    }
    Write-Output ('Process ' + $process.Name + ' is using more than 100 MB RAM.')
}

Break

The break statement causes Windows PowerShell to immediately exit the innermost While, Do, For, or ForEach loop or Switch code block.[7]

$processes = Get-Process
foreach($process in $processes)
{
    if($process.PM / 1024 / 1024 -gt 100)
    {
        Write-Output ('Process ' + $process.Name + ' is using more than 100 MB RAM.')
        break
    }
}

Exit

Exit causes Windows PowerShell to exit a script or a Windows PowerShell instance.[8]

if(<some fatal error>)
{
    Exit <optional return code>
}

Foreach-Object

The ForEach-Object cmdlet runs a command list once for each item in a collection.[9] While the ForEach-Object cmdlet is often more convenient, the foreach statement and a coded loop usually offers better performance.

Get-Process | ForEach-Object { if($_.PM / 1024 / 1024 -gt 100) {'Process ' + $_.Name + ' is using more than 100 MB RAM.'} }

Start-Sleep

The Start-Sleep cmdlet allows you to pause Windows PowerShell activity for a specified period of time.[10] It is particularly useful with long-running scripts or infinite loops.

while($true)
{
    if((Get-Date -Format 'hh:mm') -eq '00:00')
    {
        'It''s midnight.  You should go to sleep.'
    }
    Start-Sleep -Seconds 60
}

Get-Counter

The Get-Counter cmdlet gets performance counter data from local and remote computers.[11]

Get-Counter

Activities

    Create a script that asks the user to enter grade scores. Start by asking the user how many scores they would like to enter. Then use a loop to request each score and add it to a total. Finally, calculate and display the average for the entered scores. Revise the script several times to compare the code required when the loop control structure is based on while, do while, do until, and for statements, respectively.
    Review MathsIsFun: 10x Printable Multiplication Table. Create a script that uses nested for loops to generate a multiplication table. Rather than simply creating a 10 by 10 table, ask the user to enter the starting and ending values.
    Review MathsIsFun: 10x Printable Multiplication Table. Create a script that uses nested for loops to generate a multiplication table. Use a condition with (<variable> % 2) to test for odd or even values. Generate the multiplication table only for even values. For odd values, use the continue statement to continue the next iteration of the loop.
    Review MathsIsFun: 10x Printable Multiplication Table. Create a script that uses nested for loops to generate a multiplication table. Rather than simply creating a 10 by 10 table, ask the user to enter the starting and ending values. Use a break statement to terminate the loop if the count exceeds 10.
    Create a script that retrieves a list of all services and then uses foreach to display the names of all running services. While this could also be done using Select-Object, there are times when processing objects is faster and easier using foreach.
    Review Microsoft TechNet: Using the Start-Sleep Cmdlet. Write a script that uses an infinite loop to call the Get-Counter cmdlet every sixty seconds. Redirect the Get-Counter output and append it to a file. Run the script for a few minutes and then check the file contents to observe system utilization.


###set powershell code
[System.Console]::OutputEncoding = [System.Text.Encoding]::UTF8

###get system time
$global:currenttime= Set-PSBreakpoint -Variable currenttime -Mode Read -Action { $global:currenttime= Get-Date }

$ForegroundColorYellow = 'yellow'  ###define display color

####display info with time and color
Write-Host "Download started" $currenttime -foregroundcolor $ForegroundColorYellow

$Hostname=hostname.exe          #########get hostname

###test folder or file existing 
    If((test-path $MysqlFolder))
        {
         Remove-Item $MysqlFolder -Recurse -Force 2>$NULL
        }
    New-Item -ItemType Directory -Force -Path $MysqlFolder

        if(![System.IO.File]::Exists($MysqlPackageZip)){
        Write-Host "Download Mysql package..." $currenttime -foregroundcolor $ForegroundColorYellow
        Invoke-WebRequest -Uri $MysqlPackageUrl -OutFile $MysqlPackageZip
    }

###get ip address to variables
$lanSection=192.168.1.0 
$IP=Get-NetIPAddress|Where-Object{$_ -match $lanSection}|Select-Object IPAddress|findstr $lanSection|%{$_ -replace "$lanSection",""}
$MysqlBin="d:\\Mysql\\bin"         ############define directory variables



###powershell manangement iis####

$initPassword=$initPasswordLine -replace "^([\w\ ].*)(root@localhost: )(.*)",'$3'   ####regex replace sed

mysql -e "alter user root@localhost identified by 'pwd'"  2>$NULL ###redirect error to null in powershell


#####redirction null and exit code judge###
Get-Service essj |Out-Null
IF ($? -eq "True")
{
 "OK"
}
ELSE
{
 "Wrong"
}
#####redirction null and exit code judge###

#######powershell set env variable permanent
$oldpath = (Get-ItemProperty -Path ‘Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment’ -Name PATH).path
$newpath = “$oldpath;$MysqlBin”
Set-ItemProperty -Path ‘Registry::HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager\Environment’ -Name PATH -Value $newPath
#######powershell set env variable permanent

####powershell Install winrm
Enable-PSRemoting
$hn=hostname.exe
$port=5986
$Cert = New-SelfSignedCertificate -CertstoreLocation Cert:\LocalMachine\My -DnsName $hn
ls Cert:\LocalMachine\My\ >1.txt
$ID=((Get-Content -tail 3 1.txt|select-string "CN=") -split  " +")[0]
#$HN=((Get-Content -tail 3 1.txt|select-string "CN=") -split  " +")[1]|%{$_ -replace "CN=",""}
#Write-Host $id
#Write-Host $HN
cmd /c "winrm create winrm/config/Listener?Address=*+Transport=HTTPS @{Port=""$port"" ;Hostname=""$hn"";CertificateThumbprint=""$id""}"

###get winrm service && remove winrm service
cmd /c "winrm get winrm/config/Listener?Address=*+Transport=HTTPS"
#cmd /c "winrm delete winrm/config/Listener?Address=*+Transport=HTTPS"   ###clean winrm setting
####powershell Install winrm



#######Automation install bginfo
##-------------------------------------------------------------------
## Name           BgInfo Automated
## Usage          BgInfo_Automated_v1.0.ps1
## Note           Change variables were needed to fit your needs
## PSVersion      Windows PowerShell 5.0
## Creator        Wim Matthyssen
## Date           21/02/17
## Version        1
##-------------------------------------------------------------------


## Requires -RunAsAdministrator


## Variables

$BginfoUrl = 'https://download.sysinternals.com/files/BGInfo.zip'
$LogonBgiUrl = 'http://scug.be/wim/files/2017/02/LogonBgi.zip'
$BginfoZip = 'C:\BgInfo\BgInfo.zip'
$BginfoFolder = 'C:\BgInfo'
$BginfoEula = 'C:\BgInfo\Eula.txt'
$LogonBgiZip = 'C:\BgInfo\LogonBgi.zip'
$ForegroundColor1 = 'Red'
$ForegroundColor2 = 'Yellow'
$BginfoRegPath = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run'
$BginfoRegKey = 'BGInfo'
$BginfoRegKeyValue = 'C:\BgInfo\Bginfo.exe C:\BgInfo\logon.bgi /timer:0 /nolicprompt'

## Set date/time variable and write blank lines

$global:currenttime= Set-PSBreakpoint -Variable currenttime -Mode Read -Action { $global:currenttime= Get-Date }
for ($i = 1; $i -lt 4; $i++) {write-host}
Write-Host "Download started" $currenttime -foregroundcolor $ForegroundColor1

#Create BGInfo folder on C: if not exists

If(!(test-path $BginfoFolder))
{
New-Item -ItemType Directory -Force -Path $BginfoFolder
Write-Host 'BgInfo folder created' -foregroundcolor $ForegroundColor2
}


## Download, save and extract latest BgInfo software to C:\BgInfo

function AllJobs-BginfoZip{
Import-Module BitsTransfer
Start-BitsTransfer -Source $BginfoUrl -Destination $BginfoZip
Expand-Archive -LiteralPath $BginfoZip -DestinationPath $BginfoFolder
Remove-Item $BginfoZip
Remove-Item $BginfoEula
for ($i = 1; $i -lt 2; $i++) {write-host}
Write-Host 'bginfo.exe available' $currenttime -foregroundcolor $ForegroundColor2
}
AllJobs-BginfoZip


## Download, save and extract logon.bgi file to C:\BgINfo

function AllJobs-LogonBgiZip{
Invoke-WebRequest -Uri $LogonBgiUrl -OutFile $LogonBgiZip
Expand-Archive -LiteralPath $LogonBgiZip -DestinationPath $BginfoFolder
Remove-Item $LogonBgiZip
for ($i = 1; $i -lt 2; $i++) {write-host}
Write-Host 'logon.bgi available' $currenttime -foregroundcolor $ForegroundColor2
}
AllJobs-LogonBgiZip


## Create BgInfo Registry Key to AutoStart

function Add-BginfoRegKey{
New-ItemProperty -Path $BginfoRegPath -Name $BginfoRegKey -PropertyType "String" -Value $BginfoRegKeyValue
Write-Host 'BGInfo regkey added' -ForegroundColor $ForegroundColor2 
}
Add-BginfoRegKey


## Run BgInfo

C:\BgInfo\Bginfo.exe C:\BgInfo\logon.bgi /timer:0 /nolicprompt
for ($i = 1; $i -lt 2; $i++) {write-host}
Write-Host 'BgInfo has run' -foregroundcolor $ForegroundColor1


## Close PowerShell windows upon completion

stop-process -Id $PID 

##-------------------------------------------------------------------
#######Automation install bginfo

###head and tail####
Get-Content (alias: gc) is your usual option for reading a text file. You can then filter further:

gc log.txt | select -first 10 # head
gc -TotalCount 10 log.txt     # also head
gc log.txt | select -last 10  # tail
gc -Tail 10 log.txt           # also tail (since PSv3), also much faster than above option
gc log.txt | more             # or less if you have it installed
gc log.txt | %{ $_ -replace '\d+', '($0)' }         # sed
This works well enough for small files, larger ones (more than a few MiB) are probably a bit slow.

The PowerShell Community Extensions include some cmdlets for specialised file stuff (e.g. Get-FileTail).

https://stackoverflow.com/questions/9682024/how-to-do-what-head-tail-more-less-sed-do-in-powershell/41626586
###head and tail####

####awk sed grep###
####awk
((Get-Content C:\some-txt|select-string "selected_string") -split  " +")[1]

###grep 
Get-Content C:\some-txt|Where-Object{$_ -match "matched_string"}

###sed 
Get-Content C:\some-txt|%{$_ -replace "old","new"}

###replace var in file with value of variable 
$file="C:\ip-mac.txt"
$lanSection="192.168"
$ip=Get-NetIPAddress|Where-Object{$_ -match $lanSection}
(Get-Content $file)|%{$_ -replace "somestring",$ip}|Set-Content $file
####awk sed grep###


########port open and set continue
$Ipaddress= Read-Host "Enter the IP address:"
$Port= Read-host "Enter the port number to access:"
$ManagementPort=5986
$t = New-Object Net.Sockets.TcpClient
$p="pwd-text"
$user="domain\user"
$t.Connect($Ipaddress,$Port)


    if($t.Connected)
    {
        "Port $Port is operational"

$password = ConvertTo-SecureString $p  -AsPlainText -Force
$cred=new-object System.Management.Automation.PSCredential($user,$password)
Invoke-Command -ComputerName $Ipaddress -Port $ManagementPort  -Credential  $cred -UseSSL -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck) -scriptblock {
    hostname.exe
}
    }
    else
    {
        "Port $Port is closed, You may need to contact your IT team to open it. "
    }
    

########port open and set continue


#####remote powershell auto complete password Credentials
####enter remote host run something and out 
--10 powershell script 
$password = ConvertTo-SecureString "Mypassword" -AsPlainText -Force
$cred=new-object System.Management.Automation.PSCredential("domain\user",$password)
Invoke-Command -ComputerName  host-or-ip  -Port 5986  -Credential  $cred -UseSSL -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck) -scriptblock {
    hostname.exe
    Set-NetFirewallRule -DisplayName "Mysql 3306 in" -Action Allow
    Get-NetFirewallRule -DisplayName "Mysql 3306 in"
} 
--20 result
remote-machine


Name                  : {0932BAF0-D656-4087-8A0C-5CA154091FA1}
DisplayName           : MYSQL 3306 IN
Description           : 
DisplayGroup          : 
Group                 : 
Enabled               : True
Profile               : Any
Platform              : {}
Direction             : Inbound
Action                : Allow
EdgeTraversalPolicy   : Block
LooseSourceMapping    : False
LocalOnlyMapping      : False
Owner                 : 
PrimaryStatus         : OK
Status                : 已从存储区成功分析规则。 (65536)
EnforcementStatus     : NotApplicable
PolicyStoreSource     : PersistentStore
PolicyStoreSourceType : Local
PSComputerName        : ip address Here 

--end






Get-MpComputerStatus                                        ####anti virus 
Get-MpThreat
Update-MpSignature  -Verbose                                ####升级
Set-ExecutionPolicy Unrestricted                            ####permit out powershell
Start-MpScan -ScanType QuickScan
Start-MpScan -ScanPath c:\ -ScanType FullScan -ErrorAction Ignore -Verbose

Set-MpPreference -DisableRealtimeMonitoring $true           ###关闭defender
Set-MpPreference -DisableRealtimeMonitoring $false          ###开启defender

###client enable remote powershell
Enable-PSRemoting
$Cert = New-SelfSignedCertificate -CertstoreLocation Cert:\LocalMachine\My -DnsName your-vm
ls Cert:\LocalMachine\My\

7DE993538B7D7234EDFE5A592881D682487BA591  CN=remote-powershell-vm 


###cmd root 
winrm create winrm/config/Listener?Address=*+Transport=HTTPS @{
Port="5986" ;Hostname="your-vm" ;CertificateThumbprint="7DE993538B7D7234EDFE5A592881D682487BA591"}


##POWERSHELL FIREWALL ADD REMOTE POWSHELL 5986 HTTPS PORT
New-NetFirewallRule -DisplayName "Permit Remote powershell" -Direction Inbound -Action Allow -RemoteAddress 172.16.28.0/24 -Protocol TCP -LocalPort 5986
Set-NetFirewallRule -DisplayName "Permit Remote powershell" -Action block

###CHECK PORT STATUS
Get-NetFirewallRule -DisplayName "Permit Remote powershell" | Get-NetFirewallPortFilter|select PROTOCOL,LOCALPORT,REMOTEPORT

####enter remote 
Enter-PSSession -ComputerName 172.16.28.247 -Port 5986 -Credential domain\user  -UseSSL -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck)

Set-NetFirewallRule -DisplayName "Permit Mysql" -Action block





$password = ConvertTo-SecureString "your-password-plain-text-here" -AsPlainText -Force
$cred=new-object System.Management.Automation.PSCredential("wlyd\sfwmop-1",$password)
Enter-PSSession -ComputerName 172.16.2.100 -Port 5986 -Credential  $cred -UseSSL -SessionOption (New-PSSessionOption -SkipCACheck -Sk
#####remote powershell auto complete password Credentials 

1. server level
用法:

iisreset [计算机名]



    /RESTART            停止并重新启动所有 Internet 服务。

    /START              启动所有 Internet 服务。

    /STOP               停止所有 Internet 服务。

    /REBOOT             重新启动计算机。

    /REBOOTONERROR      如果启动、停止或重新启动 Internet 服务时

                        发生错误，则重新启动计算机。

    /NOFORCE            尝试正常停止 Internet 服务失败时

                        不进行强制终止。

    /TIMEOUT:val        指定等待成功停止 Internet 服务的超时值(秒)。

                        如果指定了 /REBOOTONERROR 参数，

                        则超过超时期限后会重新启动计算机。

                        重新启动服务、停止服务和重新启动计算机的默认值

                        分别是 20 秒、60 秒和 0 秒。

    /STATUS             显示所有 Internet 服务的状态。

    /ENABLE             启用本地系统上 Internet 服务的重新启动。

    /DISABLE            禁用本地系统上 Internet 服务的重新启动。


2. website level


[WebServer]: PS C:\Users\user\Documents> get-website

Name             ID   State      Physical Path                  Bindings                                                                                                                               
----             --   -----      -------------                  --------                                                                                                                               
OpeningPortal    1    Started    C:\Site\OpenningPortal         http *:80:                                                                                                                             
......


[WebServer]: PS C:\Users\user\Documents> Stop-Website "OpeningPortal"

[WebServer]: PS C:\Users\user\Documents> get-website

Name             ID   State      Physical Path                  Bindings                                                                                                                               
----             --   -----      -------------                  --------                                                                                                                               
OpeningPortal    1    Stopped    C:\Site\OpenningPortal         http *:80:                                                                                                                             
......

[WebServer]: PS C:\Users\user\Documents> Start-Website "OpeningPortal"

[WebServer]: PS C:\Users\user\Documents> get-website

Name             ID   State      Physical Path                  Bindings                                                                                                                               
----             --   -----      -------------                  --------                                                                                                                               
OpeningPortal    1    Started    C:\Site\OpenningPortal         http *:80:              

###powershell manangement iis####



Get-ChildItem -Path e:\path -Recurse -file|Get-ItemProperty -Name lastwritetime|ft pspath,lastwritetime


Get-ADUser -Filter 'name -like "username"' -Properties CN,TITLE,proxyAddresses


###########remote powershell######
1
登录您的Windows 2012 服务器，开启WinRM服务。以管理员权限打开PowerShell控制台，运行命令Enable-PSRemoting：

所有确认选择Y


2
Windows2012需要使用HTTPS连接，需要一个ssl自签名证书。
ssl自签名证书一般有三种途径生成：
•	使用第三方工具
•	使用visual studio tool
•	使用IIS
我这里安装IIS


安装role service-->centralized ssl certificate support
click server certifcates
click create self-signed certificate
generate cert

or powershell>$Cert = New-SelfSignedCertificate -CertstoreLocation Cert:\LocalMachine\My -DnsName "myHost"

3 

powershell> ls Cert:\LocalMachine\My\

PS C:\Users\Administrator> ls Cert:\LocalMachine\My\


    目录: Microsoft.PowerShell.Security\Certificate::LocalMachine\My


Thumbprint                                Subject
----------                                -------
CEA9F345AE37D3D313F954F0C1B49FD1579AD7DA  CN=your-host-name



4
使用管理员打开CMD执行如下命令：
////注意主机名和证书指纹替换为生成的信息。
c:\>winrm create winrm/config/Listener?Address=*+Transport=HTTPS @{
Port="5986" ;Hostname="your-host-name" ;CertificateThumbprint="CEA9F345AE37D3D313F954F0C1B49FD1579AD7DA"}

c:\>netstat -an|findstr "5986"
TCP    0.0.0.0:5986           0.0.0.0:0              LISTENING
TCP    [::]:5986              [::]:0                 LISTENING


5
enable 5986 port on server and security group on nat map(omit...)


6
client connect
在客户端您只需要使用命令链接就可以了：
Enter-Pssession -ComputerName IP-or-dns -port 5986 -Credential your-user-name -UseSSL -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck)


7
powershell copy file
•	PS C:\Windows\system32> $TargetSession = New-PSSession -ComputerName SrvIP -Port  5986  -Credential UserName -UseSSL -SessionOption (New-PSSessionOption -SkipCACheck -SkipCNCheck)
•	PS C:\Windows\system32> Copy-Item  -ToSession $TargetSession -Path "C:\temp\localfile.txt"  -Destination "C:\azurevm\"  -Recurse
•	PS C:\Windows\system32> Enter-PSSession  -ComputerName SrvIP -Port  5986  -Credential  UserName


tips
10 need version 5.1 ???
PS C:\WINDOWS\system32> $PSVersionTable.PSVersion


Major  Minor  Build  Revision
-----  -----  -----  --------
5      1      16299  98      

20
 windows 8.1 only support Administrator use enter-pssession ???
###########remote powershell######




=======if public ip changed send mail===============
$Username = "mail_user@mail.com";
$Password = "mail_password";


$orgin_ip = "";


function Send-ToEmail([string]$email){

    $message = new-object Net.Mail.MailMessage;
    $message.From = "your-send-title@a.com.cn";
    $message.To.Add($email);
    $message.Subject = "your-send-title@$ip";
    $message.Body = "$ip";
 
    $smtp = new-object Net.Mail.SmtpClient("mail.com", "25");
    $smtp.Credentials = New-Object System.Net.NetworkCredential($Username, $Password);
    $smtp.send($message);
 }

 while(1)
 {
 $ip=Invoke-RestMethod -Uri https://www.example.com/ip.php;
 if ($orgin_ip -ne $ip){
    Send-ToEmail  -email "your-name@example.com";
    start-sleep -Seconds 300;
    Send-ToEmail  -email "your-name@example.com";
    start-sleep -Seconds 300;
    Send-ToEmail  -email "your-name@example.com";
    $orgin_ip = $ip;
    start-sleep -Seconds 3;
    }
 }


=======if public ip changed send mail===============

###detect service status 
[array] $Services = "zabbix agent","EFS","BITS";

#######loop operation
while(1){
    foreach($srv in $Services)
    {
        if(get-service -name $srv |findstr  "Running")
        {
            #write-host "$srv ok"                           //output to console
            write-output "error $Srv Running">>c:\s.txt     //output to file
        }
    }
    start-sleep -Seconds 30
}

###detect service status to file 


############get newest file in a folder
$dir = "f:\"
$latest = Get-ChildItem -Path $dir -Recurse -file | Sort-Object LastAccessTime -Descending| Select-Object -First 1
$latest.name
############get newest file in a folder

##########返回值 return value  exit code######################
> ping 127.0.0.1 -n 1

正在 Ping 127.0.0.1 具有 32 字节的数据:
来自 127.0.0.1 的回复: 字节=32 时间<1ms TTL=128

127.0.0.1 的 Ping 统计信息:
    数据包: 已发送 = 1，已接收 = 1，丢失 = 0 (0% 丢失)，
往返行程的估计时间(以毫秒为单位):
    最短 = 0ms，最长 = 0ms，平均 = 0ms
> $lastexitcode
0
> $?
True
> ping 172.16.1.1 -n 1

正在 Ping 172.16.1.1 具有 32 字节的数据:
请求超时。

172.16.1.1 的 Ping 统计信息:
    数据包: 已发送 = 1，已接收 = 0，丢失 = 1 (100% 丢失)，
> $?
False
> $lastexitcode
0
###########返回值 return value  exit code END##################



##########日期时间的操作####################
> $td=(get-date).adddays(-1).date  ##昨天
> echo $td

2017年3月19日 0:00:00


> $td=(get-date).adddays(0).date ##今天，注意写法
> echo $td

2017年3月20日 0:00:00
##########日期时间的操作END#################

####获取目录中文件的hash值###################
>  Get-ChildItem -Recurse -path F:\bak |Where-Object
{$_.LastWriteTime -ge $yd -and $_.LastWriteTime  
-le $td} |%{Write-Host $_.FullName}  #昨天写入的文件
F:\bak\20170319
F:\bak\20170319\project20170319.rar
F:\bak\20170319\project_redirect20170319.rar
>  Get-ChildItem -Recurse -path F:\bak |Where-Object
{$_.LastWriteTime -ge $yd -and $_.LastWriteTime   #包含完整目录的昨天写入的文件
-le $td} |%{$_.FullName}
F:\bak\20170319
F:\bak\20170319\project20170319.rar
F:\bak\20170319\project_redirect20170319.rar


PS F:\>  Get-ChildItem -Recurse -path F:\bak |Where-Object
{$_.LastWriteTime -ge $yd -and $_.LastWriteTime -le $td}
 |Where-Object {$_.Mode -eq "-a---"}   |%{d:\fciv.exe $_.FullName} ##调用外部命令，Mode只处理文件，丢弃目录
//
// File Checksum Integrity Verifier version 2.05.
//
8eddc3891ed145fbd0a18da0f6151f5a f:\bak\20170319\project20170319.rar
//
// File Checksum Integrity Verifier version 2.05.
//
d214f260bf1d7da605573eabcb3f045b f:\bak\20170319\project_redirect20170319.rar



PS F:\>  Get-ChildItem -Recurse -path F:\bak |Where-Object
{$_.LastWriteTime -ge $yd -and $_.LastWriteTime -le $td}
 |Where-Object {$_.Mode -eq "-a---"}   |%{d:\fciv.exe $_.FullName}
|Select-string -Pattern "/" -NotMatch   ##将输出中的/删除？？？

支持中文字符的hash计算
> Get-ChildItem -Recurse .\ |Where-Object {$_.Mode -eq "-a---"}|%{certutil
-hashfile $_.FullName md5}|Select-String -Pattern "CertUtil: -hashfile 命令成功完成" -NotMatch


文本规范化处理命令
cat 1.txt |sed -e ':a;N;$!ba;s/\n/ /g' -e 's/MD5 哈希(文件 /\n/g' -e 's/ //g' -e 's/):/ /g' >12.txt
换行替换未空格，再“MD5 哈希(文件 ”替换未换行；再将“）：”替换为空格

文本规范化处理前文本
MD5 哈希(文件 C:\20170209\f35b6f8a-1c0c-4d8d-baae-501bf9e05dcb-荣誉证书.jpg):
88 b9 c9 00 23 e5 a7 88 47 67 7a fa ad c1 da 03
MD5 哈希(文件 C:\20170209\fe2f6c8c-fffd-4317-8d8a-0fd8e6f57d90-105715370058673088
.jpg):
c2 51 2b a5 9e 0d 97 97 d2 7a 91 85 43 6f 7e 1d
MD5 哈希(文件 C:\20170209\fea70a73-0279-460a-9538-faac2a42e4f2-营业执照最新.pdf):
f4 f5 d9 15 3d f3 7a 8b 7f 47 05 62 4d 20 f3 ac
MD5 哈希(文件 C:\20170310\a529a4a4-4d52-4805-aa11-defe69dc22d3-Scan1.pdf):
c2 e7 fe c2 67 e6 88 95 3a 52 88 ff 3c a8 25 8b
MD5 哈希(文件 C:\20170327\04c0cc85-b568-42d4-bc9d-59a286e23fbb-QQ图片20170104150028
.jpg):
d0 96 09 b9 de d4 7b cb 47 46 a9 d5 ad 71 ad fb
MD5 哈希(文件 C:\20170327\53ca258b-f25f-488c-b70e-ed089ced32b4-QQ图片20160705104140
.jpg):
4b 43 08 e3 71 5d 86 4a f4 ac 1f c8 80 e4 04 ab


文本规范化处理后文本
C:\20170209\f35b6f8a-1c0c-4d8d-baae-501bf9e05dcb-荣誉证书.jpg 88b9c90023e5a78847677afaadc1da03
C:\20170209\fe2f6c8c-fffd-4317-8d8a-0fd8e6f57d90-105715370058673088.jpg c2512ba59e0d9797d27a9185436f7e1d
C:\20170209\fea70a73-0279-460a-9538-faac2a42e4f2-营业执照最新.pdf f4f5d9153df37a8b7f4705624d20f3ac
C:\20170310\a529a4a4-4d52-4805-aa11-defe69dc22d3-Scan1.pdf c2e7fec267e688953a5288ff3ca8258b
C:\20170327\04c0cc85-b568-42d4-bc9d-59a286e23fbb-QQ图片20170104150028.jpg d09609b9ded47bcb4746a9d5ad71adfb
C:\20170327\53ca258b-f25f-488c-b70e-ed089ced32b4-QQ图片20160705104140.jpg 4b4308e3715d864af4ac1fc880e404ab

8eddc3891ed145fbd0a18da0f6151f5a f:\bak\20170319\project20170319.rar
d214f260bf1d7da605573eabcb3f045b f:\bak\20170319\project_redirect20170319.rar
####获取目录中文件的hash值END################





 多行注释
<#
sed -i "s/^!/Erase/g" $svn_log_file
sed -i "s/^D/Erase/g" $svn_log_file
#>
单行注释
#del sed*

#变量前后添加双引号，注意行首的M“和行尾的“是添加的，$($Matches[1])是第一个反向匹配，三个双引号
svn status $svn_directory| ? { $_ -match '^!\s+(.*)' } | % { Write-Output """$($Matches[1])"""}
"D:\test\add\del\新建文本文档 (4)- = ' ; `.txt"
"D:\test\add\del\新建文本文档.txt"
https://blogs.technet.microsoft.com/heyscriptingguy/2010/07/28/writing-double-quotation-marks-to-a-text-file-using-windows-powershell/
#其他各种姿势，其他特殊符号
svn status $svn_directory| ? { $_ -match '^!\s+(.*)' } | % { Write-Output ""?""$($Matches[1])"\?"k}
svn status $svn_directory| ? { $_ -match '^!\s+(.*)' } | % { Write-Output ""!""$($Matches[1])"@"}
svn status $svn_directory| ? { $_ -match '^!\s+(.*)' } | % { Write-Output ""/""$($Matches[1])"￥"}

svn status $svn_directory| ? { $_ -match '^!\s+(.*)' } | % { Write-Output "‘"$($Matches[1])"’"} #通不过




++++++string scrap++++++++
++++++++++start+++++++++
https://technet.microsoft.com/en-us/library/ee692804.aspx

$op_time=get-date -format yyyyMd-HHmm
$op_time.substring(0,8)
++++++string scrap++++++++
++++++++++end+++++++++




+++++++++++++++++++++
变量与时间定义

 #define variables
$op_src="d:\site"
$op_dst="Z:\waasiisbak"
$op_time=get-date -format yyyyMd-HHmm
$op_log="$op_dst\rc-$op_time.log"
write-output "$op_src,$op_dst,$op_time,$op_log"

结果如下

 PS C:\Users\someuser\Desktop> C:\Users\someuser\Desktop\bak-waas-iis.ps1
d:\site,Z:\waasiisbak,20161130-1456,Z:\waasiisbak\rc-20161130-1456.log
++++++++++++++++++++++++++++++



===========与计划任务互操作==================
#define variables
$op_src="C:\site"
$op_log_pos="D:\log"
$op_dst="\\172.16.100.13\image_bak\bak"  #不可以使用网络映射的驱动器方式，只能用UNC方式
$op_time=get-date -format yyyyMd-HHmm
$op_log="$op_log_pos\rc-$op_time.log"
#write-output "$op_src,$op_dst,$op_time,$op_log" #验证变量



####escape dollar###
--10 display double quote lead a quote first
$var="d:\user\zhang san"
write-host "dir is ""$var"""

Result:
dir is "d:\user\zhang san"
####escape dollar###

#Backup with robocpy & Log
robocopy $op_src $op_dst /copy:dt /e /log:$op_log /purge /r:5 /w:5 


+++++++++++PATT++++++++++
taskschd set 任务计划的设置
program:%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe #powshell path 
add parameter:-File "D:\shell\bak-waas-iis.ps1" #full path of powershell script with doble quote!!!!
++++++++++++++++++++++++++

===========计划任务互操作结束===========

 
#blank line 空行
write-output "`n"

 where-object filter (? is alias):
% is an alias for foreach-object):
This is the variable for the current value in the pipe line.

1,2,3 | %{ write-host $_ } 
For example in the above code the %{} block is called for every value in the array. The $_ variable will contain the current value.



#类似XARGS 重定向 错误和正常输出到文件
 Get-Content 5.txt |% {dir $_} 2>&1 >6.txt
Get-Content 5.txt |% {svn status $_} 2>&1 >6.txt

#bat文件中调用powershell
Powershell.exe -executionpolicy remotesigned -File C:\Users\SE\Desktop\ps.ps1

#正则文件内替换
Get-Content .\svn_log.txt | % {$_ -replace "^svn.*$","MMTV"}|Set-Content .\svn_log_done.txt
#各种替换姿势
Get-Content .\svn_ADD.txt | % {$_ -replace "^!\s+",""}|Set-Content 1.txt
Get-Content 1.txt | % {$_ -replace "^",'"'}|Set-Content 2.txt
Get-Content 2.txt | % {$_ -replace "$",'"'}|Set-Content 3.txt
 Get-Content 2.txt | % {$_ -replace "$",'"'} > 5.txt

#文件内替换
(Get-Content .\demo.txt).Replace('ma','999') |Set-Content .\demo.txt

#replace
PS C:> 'no alarms and no surprises' -replace '^no',''
alarms and no surprises
(Get-Content Input.json) `
  -replace '"(\d+),(\d{1,})"', '$1.$2' `
  -replace 'second regex', 'second replacement' |
  Out-File output.json


Get-Content -path "Input.json" | % { $_ -Replace '"(\d+),(\d{1,})"', '$1.$2' }

#permit run powershell script
Set-ExecutionPolicy Unrestricted
Set-ExecutionPolicy RemoteSigned

#$a=get-date 时间付给变量

#ouput with variable
PS D:\> $op_date=date
PS D:\> Write-Output "test1 & $op_date"
test1 & 09/04/2016 13:59:24
PS D:\> Write-Output "test1 $op_date";
test1 09/04/2016 13:59:24


#redirection
& myjob.bat 2>&1 >> C:\yLog.txt
~
 PowerShell CheatSheet – Regular Expressions
Fab 09/10/2012 News
Here is a regular expression list

. matches any character except newline
\ escape character
\w word character [a-zA-Z_0-9]
\W non-word character [^a-zA-Z_0-9]
\d Digit [0-9]
\D non-digit [^0-9]
\n new line
\r carriage return
\t tabulation
\s white space
\S non-white space
^ beginning of a line
$ end of a line
\A beginning of the string (multi-line match)
\Z end of the string (multi-line match)
\b word boundary, boundary between \w and \W
\B not a word boundary
\< beginning of a word
\> end of a word
{n} matches exaclty n times
{n,} matches a minimum of n times
{x,y} matches a min of x and max of y
(a|b) ‘a’ or ‘b’
* matches 0 or more times
+ matches 1 or more times
? matches 1 or 0 times
*? matches 0 or more times, but as few as possible
+? matches 1 or more times, but as few as possible
?? matches 0 or 1 time


解除powershell脚本允许限制，使用管理账户运行
 PS C:\WINDOWS\system32> Set-ExecutionPolicy Unrestricted
PS C:\WINDOWS\system32> Get-ExecutionPolicy
Unrestricted


###########batch update multiple proxyAddress#####
#####loop operation
Import-CsvC:\Users\someone\Desktop\user20171205.csv|
foreach{
##set SMTP
$user=get-aduser $_.username -Properties mail,department,ProxyAddresses
$user.ProxyAddresses = 'SMTP:' + $_.username + '@example.com'
set-aduser -instance $user
##SET multiple smtp
get-aduser $_.username |Set-ADUser -add @{Proxyaddresses="smtp:" + $_.username + "@eg2.com" }
##view user ProxyAddresses
get-aduser $_.username -Properties mail,department,ProxyAddresses
}
###########batch update multiple proxyAddress#####



######batch update proxyAddress of AD user                               
Import-Csv C:\Users\user\Desktop\usertxt.csv |
foreach{
$user=get-aduser $_.username -Properties mail,department,ProxyAddresses
$user.ProxyAddresses = 'SMTP:' + $_.username + '@example.com'
set-aduser -instance $user
}

######batch update proxyAddress of AD user                               


#######batch deploy linux Azure vm use csv
方法0 使用CSV格式(推荐)
需要I:\batch_deploy_vm.csv这个文件,
列名分别是myvmname和myipaddr,
值分别是
Jia    10.0.0.21
Yi     10.0.0.29
都不用引号



$MYSIZE="Small"
$myimage="zxc-centos"
$myuser="zhangsan"
$mypass="password"
$mycloud="my-cloud"
$mynet="my-net"
$mysubnet="subnet-1"

Import-Csv I:\batch_deploy_vm.csv |
foreach{
New-AzureVMConfig -name  $_.myvmname -InstanceSize $MYSIZE -ImageName $myimage |
Add-AzureProvisioningConfig -Linux -LinuxUser $myuser -Password $mypass |
Set-AzureSubnet $mysubnet |
Set-AzureStaticVNetIP $_.myipaddr |
New-AzureVM -ServiceName $mycloud -VNetName $mynet
}

######End powershell.memo #######
######Endmemoof powershell.memo #######
